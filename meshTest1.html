<!DOCTYPE html>
<html lang="fr">
<head>
Â Â Â  <meta charset="UTF-8">
Â Â Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â Â Â  <title>Visionneuse 3D Par Occlusion Oculaire - Mode DÃ©tection</title>
Â Â Â  <style>
Â Â Â Â Â Â Â  /* DÃ©but du CSS intÃ©grÃ© */
Â Â Â Â Â Â Â  body {
Â Â Â Â Â Â Â Â Â Â Â  font-family: sans-serif;
Â Â Â Â Â Â Â Â Â Â Â  display: flex;
Â Â Â Â Â Â Â Â Â Â Â  flex-direction: column;
Â Â Â Â Â Â Â Â Â Â Â  align-items: center;
Â Â Â Â Â Â Â Â Â Â Â  margin: 20px;
Â Â Â Â Â Â Â Â Â Â Â  background-color: #f0f0f0;
Â Â Â Â Â Â Â Â Â Â Â  color: #333;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  h1 {
Â Â Â Â Â Â Â Â Â Â Â  color: #0056b3;
Â Â Â Â Â Â Â Â Â Â Â  margin-bottom: 20px;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  .controls {
Â Â Â Â Â Â Â Â Â Â Â  margin-bottom: 20px;
Â Â Â Â Â Â Â Â Â Â Â  text-align: center;
Â Â Â Â Â Â Â Â Â Â Â  background-color: #fff;
Â Â Â Â Â Â Â Â Â Â Â  padding: 20px;
Â Â Â Â Â Â Â Â Â Â Â  border-radius: 8px;
Â Â Â Â Â Â Â Â Â Â Â  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
Â Â Â Â Â Â Â Â Â Â Â  width: 90%;
Â Â Â Â Â Â Â Â Â Â Â  max-width: 680px;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  button {
Â Â Â Â Â Â Â Â Â Â Â  padding: 12px 25px;
Â Â Â Â Â Â Â Â Â Â Â  font-size: 18px;
Â Â Â Â Â Â Â Â Â Â Â  cursor: pointer;
Â Â Â Â Â Â Â Â Â Â Â  background-color: #007bff;
Â Â Â Â Â Â Â Â Â Â Â  color: white;
Â Â Â Â Â Â Â Â Â Â Â  border: none;
Â Â Â Â Â Â Â Â Â Â Â  border-radius: 5px;
Â Â Â Â Â Â Â Â Â Â Â  transition: background-color 0.3s ease;
Â Â Â Â Â Â Â Â Â Â Â  margin-bottom: 15px;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  button:hover {
Â Â Â Â Â Â Â Â Â Â Â  background-color: #0056b3;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  p {
Â Â Â Â Â Â Â Â Â Â Â  margin: 8px 0;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  input[type="radio"] {
Â Â Â Â Â Â Â Â Â Â Â  margin-right: 5px;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  label {
Â Â Â Â Â Â Â Â Â Â Â  font-size: 1rem;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  #status {
Â Â Â Â Â Â Â Â Â Â Â  margin-top: 10px;
Â Â Â Â Â Â Â Â Â Â Â  font-weight: bold;
Â Â Â Â Â Â Â Â Â Â Â  color: #555;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  #statusLog {
Â Â Â Â Â Â Â Â Â Â Â  width: 90%;
Â Â Â Â Â Â Â Â Â Â Â  max-width: 500px;
Â Â Â Â Â Â Â Â Â Â Â  height: 200px;
Â Â Â Â Â Â Â Â Â Â Â  margin-top: 15px;
Â Â Â Â Â Â Â Â Â Â Â  padding: 10px;
Â Â Â Â Â Â Â Â Â Â Â  font-size: 0.9em;
Â Â Â Â Â Â Â Â Â Â Â  border: 1px solid #ddd;
Â Â Â Â Â Â Â Â Â Â Â  background-color: #f9f9f9;
Â Â Â Â Â Â Â Â Â Â Â  resize: vertical;
Â Â Â Â Â Â Â Â Â Â Â  font-family: monospace;
Â Â Â Â Â Â Â Â Â Â Â  white-space: pre-wrap;
Â Â Â Â Â Â Â Â Â Â Â  overflow-y: scroll;
Â Â Â Â Â Â Â Â Â Â Â  text-align: left; /* Align left for logs */
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  .video-container {
Â Â Â Â Â Â Â Â Â Â Â  position: relative;
Â Â Â Â Â Â Â Â Â Â Â  width: 640px;
Â Â Â Â Â Â Â Â Â Â Â  height: 480px;
Â Â Â Â Â Â Â Â Â Â Â  border: 2px solid #a0a0a0;
Â Â Â Â Â Â Â Â Â Â Â  background-color: black;
Â Â Â Â Â Â Â Â Â Â Â  display: flex;
Â Â Â Â Â Â Â Â Â Â Â  justify-content: center;
Â Â Â Â Â Â Â Â Â Â Â  align-items: center;
Â Â Â Â Â Â Â Â Â Â Â  margin-top: 25px;
Â Â Â Â Â Â Â Â Â Â Â  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  #outputCanvas {
Â Â Â Â Â Â Â Â Â Â Â  width: 100%;
Â Â Â Â Â Â Â Â Â Â Â  height: 100%;
Â Â Â Â Â Â Â Â Â Â Â  display: block;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  .param-group {
Â Â Â Â Â Â Â Â Â Â Â  margin-top: 20px;
Â Â Â Â Â Â Â Â Â Â Â  border-top: 1px solid #eee;
Â Â Â Â Â Â Â Â Â Â Â  padding-top: 15px;
Â Â Â Â Â Â Â Â Â Â Â  text-align: left;
Â Â Â Â Â Â Â Â Â Â Â  padding-left: 20px;
Â Â Â Â Â Â Â Â Â Â Â  padding-right: 20px;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  .param-group label, .param-group input[type="range"] {
Â Â Â Â Â Â Â Â Â Â Â  display: block;
Â Â Â Â Â Â Â Â Â Â Â  width: calc(100% - 20px);
Â Â Â Â Â Â Â Â Â Â Â  margin-bottom: 8px;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  .param-group span {
Â Â Â Â Â Â Â Â Â Â Â  font-weight: bold;
Â Â Â Â Â Â Â Â Â Â Â  display: inline-block;
Â Â Â Â Â Â Â Â Â Â Â  width: 150px; /* Alignement */
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  /* Fin du CSS intÃ©grÃ© */
Â Â Â  </style>
</head>
<body>
Â Â Â  <h1>ðŸ‘€ Visionneuse 3D Interactive (Mode DÃ©tection/DÃ©bug) ðŸ‘€</h1>

Â Â Â  <div class="controls">
Â Â Â Â Â Â Â  <button id="startButton">DÃ©marrer la Webcam</button>
Â Â Â Â Â Â Â  <p id="status">Statut : En attente de dÃ©marrage...</p>
Â Â Â Â Â Â Â  <textarea id="statusLog" rows="10" cols="50" readonly></textarea>
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â  <div class="param-group">
Â Â Â Â Â Â Â Â Â Â Â  <h3>ParamÃ¨tres de DÃ©tection :</h3>
Â Â Â Â Â Â Â Â Â Â Â  <p>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <label for="visibilityThreshold">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <span>Seuil de visibilitÃ© (Z-coord) :</span>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <input type="range" id="visibilityThreshold" min="0" max="1" step="0.01" value="0.05">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <span id="visibilityThresholdValue">0.05</span>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  </label>
Â Â Â Â Â Â Â Â Â Â Â  </p>
Â Â Â Â Â Â Â Â Â Â Â  <p>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <label for="minEyePointsForVisibility">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <span>Min. points par Å“il visible :</span>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <input type="range" id="minEyePointsForVisibility" min="1" max="50" step="1" value="10">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <span id="minEyePointsForVisibilityValue">10</span>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  </label>
Â Â Â Â Â Â Â Â Â Â Â  </p>
Â Â Â Â Â Â Â Â Â Â Â  <p>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <label for="faceDetectionConfidence">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <span>Confiance min. dÃ©tection visage :</span>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <input type="range" id="faceDetectionConfidence" min="0" max="1" step="0.05" value="0.9">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <span id="faceDetectionConfidenceValue">0.9</span>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  </label>
Â Â Â Â Â Â Â Â Â Â Â  </p>
Â Â Â Â Â Â Â Â Â Â Â  <p>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <label for="frameRate">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <span>FrÃ©quence d'analyse (ms) :</span>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <input type="range" id="frameRate" min="10" max="500" step="10" value="50">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <span id="frameRateValue">50 ms</span>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  </label>
Â Â Â Â Â Â Â Â Â Â Â  </p>
Â Â Â Â Â Â Â Â Â Â Â Â  <p>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <input type="checkbox" id="showLandmarks" checked>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <label for="showLandmarks">Afficher les points de dÃ©tection</label>
Â Â Â Â Â Â Â Â Â Â Â  </p>
Â Â Â Â Â Â Â Â Â Â Â  <p>
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <input type="checkbox" id="showBoundingBox">
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  <label for="showBoundingBox">Afficher le cadre du visage</label>
Â Â Â Â Â Â Â Â Â Â Â  </p>
Â Â Â Â Â Â Â  </div>

Â Â Â Â Â Â Â  <h3>Mode d'affichage (deux yeux visibles) :</h3>
Â Â Â Â Â Â Â  <p>
Â Â Â Â Â Â Â Â Â Â Â  <input type="radio" id="modeBlack" name="twoEyesMode" value="black" checked>
Â Â Â Â Â Â Â Â Â Â Â  <label for="modeBlack">Ã‰cran noir</label>
Â Â Â Â Â Â Â  </p>
Â Â Â Â Â Â Â  <p>
Â Â Â Â Â Â Â Â Â Â Â  <input type="radio" id="modeSideBySide" name="twoEyesMode" value="sidebyside">
Â Â Â Â Â Â Â Â Â Â Â  <label for="modeSideBySide">CÃ´tÃ© Ã  cÃ´tÃ©</label>
Â Â Â Â Â Â Â  </p>
Â Â Â Â Â Â Â  <p>
Â Â Â Â Â Â Â Â Â Â Â  <input type="radio" id="modeMono" name="twoEyesMode" value="mono">
Â Â Â Â Â Â Â Â Â Â Â  <label for="modeMono">Image unique (gauche)</label>
Â Â Â Â Â Â Â  </p>
Â Â Â  </div>

Â Â Â  <div class="video-container">
Â Â Â Â Â Â Â  <video id="webcamVideo" autoplay playsinline style="display: none;"></video>
Â Â Â Â Â Â Â  <canvas id="outputCanvas"></canvas>
Â Â Â  </div>

Â Â Â  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.x/dist/tf.min.js"></script>
Â Â Â  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.1/dist/face-landmarks-detection.min.js"></script>

Â Â Â  <script>
Â Â Â Â Â Â Â  /* DÃ©but du JavaScript intÃ©grÃ© */
Â Â Â Â Â Â Â  const webcamVideo = document.getElementById('webcamVideo');
Â Â Â Â Â Â Â  const outputCanvas = document.getElementById('outputCanvas');
Â Â Â Â Â Â Â  const ctx = outputCanvas.getContext('2d');
Â Â Â Â Â Â Â  const startButton = document.getElementById('startButton');
Â Â Â Â Â Â Â  const statusLogElement = document.getElementById('statusLog');
Â Â Â Â Â Â Â  const statusElement = document.getElementById('status');

Â Â Â Â Â Â Â  // Ã‰lÃ©ments pour les paramÃ¨tres
Â Â Â Â Â Â Â  const visibilityThresholdSlider = document.getElementById('visibilityThreshold');
Â Â Â Â Â Â Â  const visibilityThresholdValueSpan = document.getElementById('visibilityThresholdValue');
Â Â Â Â Â Â Â  const minEyePointsForVisibilitySlider = document.getElementById('minEyePointsForVisibility');
Â Â Â Â Â Â Â  const minEyePointsForVisibilityValueSpan = document.getElementById('minEyePointsForVisibilityValue');
Â Â Â Â Â Â Â  const faceDetectionConfidenceSlider = document.getElementById('faceDetectionConfidence'); // Nouveau slider
Â Â Â Â Â Â Â  const faceDetectionConfidenceValueSpan = document.getElementById('faceDetectionConfidenceValue'); // Nouveau span
Â Â Â Â Â Â Â  const frameRateSlider = document.getElementById('frameRate');
Â Â Â Â Â Â Â  const frameRateValueSpan = document.getElementById('frameRateValue');
Â Â Â Â Â Â Â  const showLandmarksCheckbox = document.getElementById('showLandmarks');
Â Â Â Â Â Â Â  const showBoundingBoxCheckbox = document.getElementById('showBoundingBox'); // Nouvelle checkbox


Â Â Â Â Â Â Â  let model;
Â Â Â Â Â Â Â  let animationFrameId;
Â Â Â Â Â Â Â  let lastStatusMessage = '';
Â Â Â Â Â Â Â  let lastDetectionTime = 0;

Â Â Â Â Â Â Â  // ParamÃ¨tres configurables
Â Â Â Â Â Â Â  let visibilityThreshold = parseFloat(visibilityThresholdSlider.value);
Â Â Â Â Â Â Â  let minEyePointsForVisibility = parseInt(minEyePointsForVisibilitySlider.value);
Â Â Â Â Â Â Â  let faceDetectionConfidence = parseFloat(faceDetectionConfidenceSlider.value); // Nouvelle variable
Â Â Â Â Â Â Â  let desiredFrameRate = parseInt(frameRateSlider.value);
Â Â Â Â Â Â Â  let showLandmarks = showLandmarksCheckbox.checked;
Â Â Â Â Â Â Â  let showBoundingBox = showBoundingBoxCheckbox.checked; // Nouvelle variable


Â Â Â Â Â Â Â  // Mise Ã  jour des valeurs affichÃ©es des sliders
Â Â Â Â Â Â Â  visibilityThresholdSlider.oninput = () => {
Â Â Â Â Â Â Â Â Â Â Â  visibilityThreshold = parseFloat(visibilityThresholdSlider.value);
Â Â Â Â Â Â Â Â Â Â Â  visibilityThresholdValueSpan.textContent = visibilityThreshold;
Â Â Â Â Â Â Â  };
Â Â Â Â Â Â Â  minEyePointsForVisibilitySlider.oninput = () => {
Â Â Â Â Â Â Â Â Â Â Â  minEyePointsForVisibility = parseInt(minEyePointsForVisibilitySlider.value);
Â Â Â Â Â Â Â Â Â Â Â  minEyePointsForVisibilityValueSpan.textContent = minEyePointsForVisibility;
Â Â Â Â Â Â Â  };
Â Â Â Â Â Â Â  faceDetectionConfidenceSlider.oninput = () => { // Nouveau gestionnaire
Â Â Â Â Â Â Â Â Â Â Â  faceDetectionConfidence = parseFloat(faceDetectionConfidenceSlider.value);
Â Â Â Â Â Â Â Â Â Â Â  faceDetectionConfidenceValueSpan.textContent = faceDetectionConfidence;
Â Â Â Â Â Â Â  };
Â Â Â Â Â Â Â  frameRateSlider.oninput = () => {
Â Â Â Â Â Â Â Â Â Â Â  desiredFrameRate = parseInt(frameRateSlider.value);
Â Â Â Â Â Â Â Â Â Â Â  frameRateValueSpan.textContent = `${desiredFrameRate} ms`;
Â Â Â Â Â Â Â  };
Â Â Â Â Â Â Â  showLandmarksCheckbox.onchange = () => {
Â Â Â Â Â Â Â Â Â Â Â  showLandmarks = showLandmarksCheckbox.checked;
Â Â Â Â Â Â Â  };
Â Â Â Â Â Â Â  showBoundingBoxCheckbox.onchange = () => { // Nouveau gestionnaire
Â Â Â Â Â Â Â Â Â Â Â  showBoundingBox = showBoundingBoxCheckbox.checked;
Â Â Â Â Â Â Â  };


Â Â Â Â Â Â Â  // Dimensions du canvas
Â Â Â Â Â Â Â  const CANVAS_WIDTH = 640;
Â Â Â Â Â Â Â  const CANVAS_HEIGHT = 480;

Â Â Â Â Â Â Â  outputCanvas.width = CANVAS_WIDTH;
Â Â Â Â Â Â Â  outputCanvas.height = CANVAS_HEIGHT;

Â Â Â Â Â Â Â  // Chargement des images 3D (remplacez par vos propres chemins !)
Â Â Â Â Â Â Â  const imageLeft = new Image();
Â Â Â Â Â Â Â  imageLeft.src = 'photos3d/gImgMer1.jpg';
Â Â Â Â Â Â Â  const imageRight = new Image();
Â Â Â Â Â Â Â  imageRight.src = 'photos3d/dImgMer1.jpg';

Â Â Â Â Â Â Â  let imagesLoaded = false;
Â Â Â Â Â Â Â  let imagesToLoad = 2;

Â Â Â Â Â Â Â  function imageLoaded() {
Â Â Â Â Â Â Â Â Â Â Â  imagesToLoad--;
Â Â Â Â Â Â Â Â Â Â Â  if (imagesToLoad === 0) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  imagesLoaded = true;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog('Images 3D chargÃ©es. PrÃªt.');
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  imageLeft.onload = imageLoaded;
Â Â Â Â Â Â Â  imageRight.onload = imageLoaded;
Â Â Â Â Â Â Â  imageLeft.onerror = () => { updateStatusLog('Erreur: Impossible de charger l\'image gauche.'); };
Â Â Â Â Â Â Â  imageRight.onerror = () => { updateStatusLog('Erreur: Impossible de charger l\'image droite.'); };

Â Â Â Â Â Â Â  function updateStatusLog(message) {
Â Â Â Â Â Â Â Â Â Â Â  const now = new Date();
Â Â Â Â Â Â Â Â Â Â Â  const timeString = now.toLocaleTimeString('fr-FR', {hour: '2-digit', minute:'2-digit', second:'2-digit'});
Â Â Â Â Â Â Â Â Â Â Â  const fullMessage = `[${timeString}] ${message}`;

Â Â Â Â Â Â Â Â Â Â Â  if (message !== lastStatusMessage) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  statusLogElement.value += fullMessage + '\n';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  statusLogElement.scrollTop = statusLogElement.scrollHeight;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  lastStatusMessage = message;
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  statusElement.textContent = `Statut : ${message.split('\n')[0]}`;
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  async function setupWebcam() {
Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog('DÃ©marrage de la webcam...');
Â Â Â Â Â Â Â Â Â Â Â  try {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  webcamVideo.srcObject = stream;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return new Promise((resolve) => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  webcamVideo.onloadedmetadata = () => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  webcamVideo.play();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  resolve();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  };
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  });
Â Â Â Â Â Â Â Â Â Â Â  } catch (error) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.error('Erreur d\'accÃ¨s Ã  la webcam:', error);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog(`Erreur: AccÃ¨s Ã  la webcam refusÃ© ou impossible. (${error.name} - ${error.message || 'Cause inconnue'})`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  alert('Impossible d\'accÃ©der Ã  la webcam. Assurez-vous qu\'elle est connectÃ©e et que vous avez accordÃ© la permission.');
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }
/*
Â Â Â Â Â Â Â  async function loadFaceMeshModel_Old() {
Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog('Chargement du modÃ¨le FaceMesh...');
Â Â Â Â Â Â Â Â Â Â Â  const detectorConfig = {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  runtime: 'tfjs',
Â Â Â Â Â Â Â Â Â Â Â  };
Â Â Â Â Â Â Â Â Â Â Â  try {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  model = await faceLandmarksDetection.createDetector(faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh, detectorConfig);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog('ModÃ¨le FaceMesh chargÃ©.');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.log('FaceMesh model loaded successfully with TFJS runtime.');
Â Â Â Â Â Â Â Â Â Â Â  } catch (error) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.error('Erreur lors du chargement du modÃ¨le FaceMesh:', error);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog(`Erreur: Impossible de charger le modÃ¨le FaceMesh. (${error.message || 'VÃ©rifiez la console.'})`);
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }
*/

	async function loadFaceMeshModel() {
	    updateStatusLog('Chargement du modÃ¨le FaceMesh...');
	    try {
		// Tenter de forcer le backend CPU pour le test
		await tf.setBackend('cpu'); 
		await tf.ready(); // S'assurer que le backend est prÃªt
		const detectorConfig = {
		    runtime: 'tfjs',
		};
		model = await faceLandmarksDetection.createDetector(faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh, detectorConfig);
		updateStatusLog('ModÃ¨le FaceMesh chargÃ©.');
		console.log('FaceMesh model loaded successfully with TFJS runtime and CPU backend (for testing).');
	    } catch (error) {
		console.error('Erreur lors du chargement du modÃ¨le FaceMesh:', error);
		updateStatusLog(`Erreur: Impossible de charger le modÃ¨le FaceMesh. (${error.message || 'VÃ©rifiez la console.'})`);
	    }
	}

Â Â Â Â Â Â Â  // Indices des points clÃ©s pour les contours des yeux FaceMesh
Â Â Â Â Â Â Â  const LEFT_EYE_CONTOUR_INDICES = [
Â Â Â Â Â Â Â Â Â Â Â  33, 7, 163, 144, 145, 153, 154, 155, 133,
Â Â Â Â Â Â Â Â Â Â Â  246, 161, 160, 159, 158, 157, 173,
Â Â Â Â Â Â Â  ];
Â Â Â Â Â Â Â  const RIGHT_EYE_CONTOUR_INDICES = [
Â Â Â Â Â Â Â Â Â Â Â  362, 382, 381, 380, 374, 373, 390, 249,
Â Â Â Â Â Â Â Â Â Â Â  466, 388, 387, 386, 385, 384, 398,
Â Â Â Â Â Â Â  ];

Â Â Â Â Â Â Â  const checkEyeOcclusion = (faceMesh, indices) => {
Â Â Â Â Â Â Â Â Â Â Â  let detectedPointsInEye = 0;
Â Â Â Â Â Â Â Â Â Â Â  for (const idx of indices) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (faceMesh[idx] && faceMesh[idx][2] > visibilityThreshold) { // [2] est la coordonnÃ©e Z (confiance/visibilitÃ©)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  detectedPointsInEye++;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  return detectedPointsInEye >= minEyePointsForVisibility;
Â Â Â Â Â Â Â  };

Â Â Â Â Â Â Â  // Fonction pour dessiner les points dÃ©tectÃ©s sur le canvas
Â Â Â Â Â Â Â  function drawLandmarks(landmarks, color = 'lime') {
Â Â Â Â Â Â Â Â Â Â Â  if (!landmarks) return;
Â Â Â Â Â Â Â Â Â Â Â  ctx.fillStyle = color;
Â Â Â Â Â Â Â Â Â Â Â  for (const landmark of landmarks) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const x = landmark[0] * (CANVAS_WIDTH / webcamVideo.videoWidth);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const y = landmark[1] * (CANVAS_HEIGHT / webcamVideo.videoHeight);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.beginPath();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.arc(x, y, 2, 0, 2 * Math.PI);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.fill();
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â  // Fonction pour dessiner un rectangle de dÃ©limitation
Â Â Â Â Â Â Â  function drawBoundingBox(box, color = 'red') {
Â Â Â Â Â Â Â Â Â Â Â  ctx.strokeStyle = color;
Â Â Â Â Â Â Â Â Â Â Â  ctx.lineWidth = 2;
Â Â Â Â Â Â Â Â Â Â Â  // Assurez-vous que les coordonnÃ©es du bounding box sont correctement mises Ã  l'Ã©chelle pour le canvas
Â Â Â Â Â Â Â Â Â Â Â  const startX = box.xMin * (CANVAS_WIDTH / webcamVideo.videoWidth);
Â Â Â Â Â Â Â Â Â Â Â  const startY = box.yMin * (CANVAS_HEIGHT / webcamVideo.videoHeight);
Â Â Â Â Â Â Â Â Â Â Â  const width = box.width * (CANVAS_WIDTH / webcamVideo.videoWidth);
Â Â Â Â Â Â Â Â Â Â Â  const height = box.height * (CANVAS_HEIGHT / webcamVideo.videoHeight);
Â Â Â Â Â Â Â Â Â Â Â  ctx.strokeRect(startX, startY, width, height);
Â Â Â Â Â Â Â Â Â Â Â  ctx.fillStyle = color;
Â Â Â Â Â Â Â Â Â Â Â  ctx.font = '12px Arial';
Â Â Â Â Â Â Â Â Â Â Â  ctx.fillText(`Confiance: ${box.score.toFixed(2)}`, startX + 5, startY + 15);
Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  async function detectAndDraw() {
Â Â Â Â Â Â Â Â Â Â Â  console.log('detectAndDraw: AppelÃ©e.'); 
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  const now = performance.now();
Â Â Â Â Â Â Â Â Â Â Â  if (now - lastDetectionTime < desiredFrameRate) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  animationFrameId = requestAnimationFrame(detectAndDraw);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return;
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  lastDetectionTime = now;
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  if (!model || !webcamVideo.srcObject || !imagesLoaded) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  let reason = '';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (!model) reason += 'ModÃ¨le non chargÃ©. ';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (!webcamVideo.srcObject) reason += 'Webcam non prÃªte. ';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (!imagesLoaded) reason += 'Images 3D non chargÃ©es. ';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.log(`detectAndDraw: Terminaison anticipÃ©e - ${reason}`);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  animationFrameId = requestAnimationFrame(detectAndDraw);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return;
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  // --- Dessine la vidÃ©o de la webcam sur le canvas en premier ---
Â Â Â Â Â Â Â Â Â Â Â  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
Â Â Â Â Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  console.log('detectAndDraw: Tentative de dessin de la webcam.'); 
Â Â Â Â Â Â Â Â Â Â Â  console.log(`Webcam video dimensions: ${webcamVideo.videoWidth}x${webcamVideo.videoHeight}`); 
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  if (webcamVideo.videoWidth > 0 && webcamVideo.videoHeight > 0) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.drawImage(webcamVideo, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.warn('Webcam video dimensions are zero, cannot draw yet.');
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  // *** MODIFICATION ICI : flipHorizontal: true et logs de prÃ©diction ***
	    console.log(`Dimensions de la vidÃ©o avant estimation : ${webcamVideo.videoWidth}x${webcamVideo.videoHeight}`); // AJOUTEZ CE LOG
Â Â Â Â Â Â Â Â Â Â Â  const predictions = await model.estimateFaces(webcamVideo, { flipHorizontal: false, minDetectionConfidence: faceDetectionConfidence });

Â Â Â Â Â Â Â Â Â Â Â  console.log('Nombre de prÃ©dictions FaceMesh:', predictions.length); // NOUVEAU LOG
Â Â Â Â Â Â Â Â Â Â Â  if (predictions.length > 0) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.log('DÃ©tails de la premiÃ¨re prÃ©diction:', predictions[0]); // NOUVEAU LOG
		const face = predictions[0];
    		console.log('Premier point de scaledMesh:', face.scaledMesh[0]); // Devrait afficher [x, y, z] numÃ©riques
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  let leftEyeVisible = false;
Â Â Â Â Â Â Â Â Â Â Â  let rightEyeVisible = false;
Â Â Â Â Â Â Â Â Â Â Â  let currentStatusMessage = 'Aucun visage dÃ©tectÃ©.';

Â Â Â Â Â Â Â Â Â Â Â  if (predictions.length > 0) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const face = predictions[0]; 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (showBoundingBox && face.box) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  drawBoundingBox(face.box, 'cyan'); 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
/*
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (face.scaledMesh) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  leftEyeVisible = checkEyeOcclusion(face.scaledMesh, LEFT_EYE_CONTOUR_INDICES);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  rightEyeVisible = checkEyeOcclusion(face.scaledMesh, RIGHT_EYE_CONTOUR_INDICES);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (showLandmarks) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  drawLandmarks(face.scaledMesh, 'rgba(255, 255, 0, 0.5)'); 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  for(const idx of LEFT_EYE_CONTOUR_INDICES) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if(face.scaledMesh[idx]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const pt = face.scaledMesh[idx];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const x = pt[0] * (CANVAS_WIDTH / webcamVideo.videoWidth);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const y = pt[1] * (CANVAS_HEIGHT / webcamVideo.videoHeight);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.fillStyle = 'red';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.beginPath();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.arc(x, y, 3, 0, 2 * Math.PI);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.fill();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.font = '10px Arial';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.fillText(pt[2].toFixed(2), x + 5, y - 5); 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  for(const idx of RIGHT_EYE_CONTOUR_INDICES) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if(face.scaledMesh[idx]) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const pt = face.scaledMesh[idx];
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const x = pt[0] * (CANVAS_WIDTH / webcamVideo.videoWidth);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const y = pt[1] * (CANVAS_HEIGHT / webcamVideo.videoHeight);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.fillStyle = 'blue';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.beginPath();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.arc(x, y, 3, 0, 2 * Math.PI);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.fill();
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.font = '10px Arial';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.fillText(pt[2].toFixed(2), x + 5, y - 5); 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const leftEyePointsCount = face.scaledMesh.filter((p, i) => LEFT_EYE_CONTOUR_INDICES.includes(i) && p[2] > visibilityThreshold).length;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const rightEyePointsCount = face.scaledMesh.filter((p, i) => RIGHT_EYE_CONTOUR_INDICES.includes(i) && p[2] > visibilityThreshold).length;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage = `Visage dÃ©tectÃ© (Conf: ${face.box.score.toFixed(2)}). `;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage += `Å’il G: ${leftEyeVisible ? 'Visible' : 'MasquÃ©'} (${leftEyePointsCount}/${LEFT_EYE_CONTOUR_INDICES.length}), `;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage += `Å’il D: ${rightEyeVisible ? 'Visible' : 'MasquÃ©'} (${rightEyePointsCount}/${RIGHT_EYE_CONTOUR_INDICES.length})`;

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage = 'Visage dÃ©tectÃ©, mais donnÃ©es de points clÃ©s absentes ou incomplÃ¨tes. Ajustez la confiance ou l\'Ã©clairage.';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage = 'Aucun visage dÃ©tectÃ©.';
Â Â Â Â Â Â Â Â Â Â Â  }
*/
	    if (predictions.length > 0) {
		    const face = predictions[0];
		    const scaledMesh = face.scaledMesh; // Les 468 points dÃ©tectÃ©s
		
		    if (scaledMesh && scaledMesh.length > 0) {
		        // Calculez min/max X et Y Ã  partir des points dÃ©tectÃ©s
		        let minX = Infinity;
		        let minY = Infinity;
		        let maxX = -Infinity;
		        let maxY = -Infinity;
		
		        for (const point of scaledMesh) {
		            // Les points sont des tableaux [x, y, z]
		            minX = Math.min(minX, point[0]);
		            minY = Math.min(minY, point[1]);
		            maxX = Math.max(maxX, point[0]);
		            maxY = Math.max(maxY, point[1]);
		        }
		
		        // CrÃ©ez un objet bounding box "sÃ»r"
		        const customBoundingBox = {
		            xMin: minX,
		            yMin: minY,
		            width: maxX - minX,
		            height: maxY - minY,
		            score: face.box ? face.box.score : 1.0 // Utilisez le score existant ou un par dÃ©faut
		        };
		
		        // Utilisez ce customBoundingBox pour le dessin
		        if (showBoundingBox) {
		            // Adaptez la fonction drawBoundingBox pour prendre ces valeurs brutes
		            // ou assurez-vous qu'elle gÃ¨re bien les conversions d'Ã©chelle.
		            // Par exemple, en passant les dimensions brutes et en laissant la fonction les scaler
		            drawBoundingBoxFromRaw(customBoundingBox, 'cyan'); // Nouvelle fonction ou modifiez l'existante
		        }
		
		        // ... (le reste de votre logique de visibilitÃ© des yeux et affichage des points)
		        // Assurez-vous que les lignes qui utilisaient face.box.score utilisent maintenant customBoundingBox.score
		        currentStatusMessage = `Visage dÃ©tectÃ© (Conf: ${customBoundingBox.score.toFixed(2)}). `;
		
		    } else {
		        currentStatusMessage = 'Visage dÃ©tectÃ©, mais donnÃ©es de points clÃ©s absentes ou incomplÃ¨tes. Ajustez la confiance ou l\'Ã©clairage.';
		    }
	    } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage = 'Aucun visage dÃ©tectÃ©.';
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  if (!showLandmarks) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 

Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (leftEyeVisible && !rightEyeVisible) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.drawImage(imageLeft, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage += ' -> Image Gauche';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  } else if (!leftEyeVisible && rightEyeVisible) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.drawImage(imageRight, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage += ' -> Image Droite';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  const twoEyesMode = document.querySelector('input[name="twoEyesMode"]:checked').value;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (twoEyesMode === 'black') {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.fillStyle = 'black';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage += ' -> Ã‰cran Noir';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  } else if (twoEyesMode === 'sidebyside') {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.drawImage(imageLeft, 0, 0, CANVAS_WIDTH / 2, CANVAS_HEIGHT);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.drawImage(imageRight, CANVAS_WIDTH / 2, 0, CANVAS_WIDTH / 2, CANVAS_HEIGHT);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage += ' -> CÃ´tÃ© Ã  CÃ´tÃ©';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  } else if (twoEyesMode === 'mono') {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ctx.drawImage(imageLeft, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  currentStatusMessage += ' -> Image Unique';
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  } else {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Si showLandmarks est activÃ©, la vidÃ©o de la webcam est dÃ©jÃ  dessinÃ©e.
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // On ajoute juste l'information de l'Ã©tat des yeux au statut.
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  // Le message est dÃ©jÃ  construit plus haut.
Â Â Â Â Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog(currentStatusMessage);

Â Â Â Â Â Â Â Â Â Â Â  animationFrameId = requestAnimationFrame(detectAndDraw);
Â Â Â Â Â Â Â  }

Â Â Â Â Â Â Â  startButton.addEventListener('click', async () => {
Â Â Â Â Â Â Â Â Â Â Â  statusLogElement.value = '';
Â Â Â Â Â Â Â Â Â Â Â  lastStatusMessage = '';
Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog('DÃ©marrage de l\'application...');
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  if (!model) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  await loadFaceMeshModel();
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  if (!model) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog('Impossible de continuer sans le modÃ¨le FaceMesh. Corrigez les erreurs.');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.error('Model not loaded, aborting startup.'); 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return;
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  await setupWebcam();
Â Â Â Â Â Â Â Â Â Â Â  if (!webcamVideo.srcObject) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog('Impossible de continuer sans l\'accÃ¨s Ã  la webcam. Corrigez les permissions.');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.error('Webcam not ready, aborting startup.'); 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return;
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â  Â 
Â Â Â Â Â Â Â Â Â Â Â  webcamVideo.onloadeddata = () => { 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.log('Webcam video loadeddata event fired. Starting detection loop.');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (animationFrameId) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  cancelAnimationFrame(animationFrameId);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog('Webcam dÃ©marrÃ©e. DÃ©tection en cours...');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  animationFrameId = requestAnimationFrame(detectAndDraw);
Â Â Â Â Â Â Â Â Â Â Â  };
Â Â Â Â Â Â Â Â Â Â Â  setTimeout(() => {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (!animationFrameId && webcamVideo.srcObject) {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  console.warn("Webcam loadeddata event did not fire within expected time. Forcing detectAndDraw start.");
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  updateStatusLog('Webcam dÃ©marrÃ©e (force). DÃ©tection en cours...');
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  animationFrameId = requestAnimationFrame(detectAndDraw);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  }, 3000); 
Â Â Â Â Â Â Â  });
Â Â Â Â Â Â Â  /* Fin du JavaScript intÃ©grÃ© */
Â Â Â  </script>
</body>
</html>
